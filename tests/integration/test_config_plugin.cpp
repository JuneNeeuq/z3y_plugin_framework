/*
* Copyright [2025] [Yue Liu]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/**
 * @file test_config_plugin.cpp
 * @brief [集成测试] 配置管理插件全功能验证与最佳实践示例。
 * @author Yue Liu
 * @date 2025-11-22
 *
 * @details
 * =============================================================================
 * [测试覆盖矩阵 (Test Matrix)]
 * =============================================================================
 *
 * 1. **核心生命周期 (Lifecycle)**
 * - @ref AutoGenerateDefaultFile : 零配置启动 (Zero Config)，自动生成默认文件。
 * - @ref ReadWriteCycle        : 标准的读取-修改-保存-重载流程。
 *
 * 2. **高级特性 (Advanced Features)**
 * - @ref PeekModeNoSideEffect  : 探测模式 (Peek)，读取配置但不产生副作用。
 * - @ref ValidationInterception: 侵入式自校验，拦截非法参数。
 * - @ref BatchOperations       : 批量保存与重置。
 *
 * 3. **健壮性与安全 (Robustness & Security)**
 * - @ref ChineseSupport        : 中文文件名、中文 Key/Value 的正确读写 (UTF-8)。
 * - @ref CorruptedJsonDefense  : 畸形 JSON (语法错误) 的防御与现场保留。
 * - @ref TypeMismatchDefense   : 数据类型不匹配的防御。
 * - @ref PathTraversalDefense  : 路径遍历攻击 (../../) 的拦截。
 *
 * 4. **运维操作 (Operations)**
 * - @ref FactoryReset          : 单个配置恢复出厂设置。
 */

#include "common/plugin_test_base.h"
#include "interfaces_core/i_config_service.h"
#include <nlohmann/json.hpp>
#include <fstream>
#include <vector>

 // 平台特定头文件 (用于解决 Windows 下的路径编码问题)
#ifdef _WIN32
#include <Windows.h>
#endif

using namespace z3y;
using namespace z3y::interfaces::core;

// =============================================================================
// 1. [Mock Data] 业务配置结构体定义
// =============================================================================

/**
 * @brief [示例 1] 标准服务器配置
 * @note 使用 NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT 宏，
 * 当 JSON 中缺少字段时，会自动使用结构体定义的默认值。
 */
struct ServerConfig {
    int port = 8080;             // 默认端口
    std::string host = "0.0.0.0"; // 默认主机

    // 序列化宏
    NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT(ServerConfig, port, host);
};

/**
 * @brief [示例 2] 带自校验逻辑的配置
 * @note 定义了 Validate 函数，框架会在 LoadConfig 时自动调用。
 */
struct ValidatedConfig {
    int speed = 0;
    std::string name;

    /**
     * @brief 自校验回调
     * @param[out] err 错误信息，若校验失败需填充此字段。
     * @return true 校验通过; false 校验失败 (LoadConfig 将返回 Error)。
     */
    bool Validate(std::string& err) {
        // 1. 范围检查
        if (speed < 0 || speed > 100) {
            err = "Speed out of range (0-100)";
            return false;
        }
        // 2. 必填项检查
        if (name.empty()) {
            err = "Name cannot be empty";
            return false;
        }
        return true;
    }
    NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT(ValidatedConfig, speed, name);
};

/**
 * @brief [示例 3] 中文配置 (测试 Unicode 支持)
 */
struct ChineseConfig {
    std::string message = "默认消息";
    std::string location = "未知地点";
    NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT(ChineseConfig, message, location);
};

// =============================================================================
// 2. 测试夹具 (Test Fixture)
// =============================================================================

class ConfigPluginTest : public PluginTestBase {
protected:
    void SetUp() override {
        PluginTestBase::SetUp();

        // 1. 加载核心插件
        ASSERT_TRUE(LoadPlugin("plugin_config_manager"));

        // 2. 获取服务接口
        config_svc_ = z3y::GetDefaultService<IConfigManagerService>();
        ASSERT_NE(config_svc_, nullptr);

        // 3. 准备测试环境
        // 将测试根目录指向 bin/test_configs_env，保持环境隔离
        test_root_ = bin_dir_ / "test_configs_env";

        // 清理旧数据 (确保测试环境纯净)
        if (std::filesystem::exists(test_root_)) {
            std::filesystem::remove_all(test_root_);
        }

        // 4. 初始化服务
        // [关键] InitializeService 接口契约要求传入 UTF-8 编码的字符串。
        std::string root_utf8 = PathToUtf8(test_root_);
        ASSERT_TRUE(config_svc_->InitializeService(root_utf8));
    }

    void TearDown() override {
        config_svc_.reset();

        // 测试结束后清理现场 (调试时可注释掉此行以查看生成的 JSON 文件)
        if (std::filesystem::exists(test_root_)) {
            std::filesystem::remove_all(test_root_);
        }

        PluginTestBase::TearDown();
    }

    // --- [辅助工具] 编码转换 (解决 Windows 中文路径乱码问题) ---

    /**
     * @brief 将 path 对象转为 UTF-8 字符串 (传给 Service API 使用)
     */
    std::string PathToUtf8(const std::filesystem::path& path) {
#ifdef _WIN32
        std::wstring wstr = path.wstring();
        if (wstr.empty()) return "";
        int size = WideCharToMultiByte(CP_UTF8, 0, &wstr[0], (int)wstr.size(), NULL, 0, NULL, NULL);
        std::string str(size, 0);
        WideCharToMultiByte(CP_UTF8, 0, &wstr[0], (int)wstr.size(), &str[0], size, NULL, NULL);
        return str;
#else
        return path.string();
#endif
    }

    /**
     * @brief 将 UTF-8 字符串 (Domain) 转为本地 path 对象 (测试代码访问磁盘使用)
     * @note Windows 下必须转为 WideChar 才能正确访问包含中文的文件名。
     */
    std::filesystem::path DomainToPath(const std::string& domain) {
#ifdef _WIN32
        if (domain.empty()) return std::filesystem::path();
        int size = MultiByteToWideChar(CP_UTF8, 0, &domain[0], (int)domain.size(), NULL, 0);
        std::wstring wstr(size, 0);
        MultiByteToWideChar(CP_UTF8, 0, &domain[0], (int)domain.size(), &wstr[0], size);
        return test_root_ / (wstr + L".json");
#else
        return test_root_ / (domain + ".json");
#endif
    }

    // -------------------------------------------------------------

    // [Helper] 检查磁盘上文件是否存在
    bool FileExists(const std::string& domain) {
        return std::filesystem::exists(DomainToPath(domain));
    }

    // [Helper] 写入原始文件内容 (用于制造故障场景)
    void WriteRawFile(const std::string& domain, const std::string& content) {
        std::filesystem::create_directories(test_root_);
        // 使用 binary 模式写入，避免 Windows 下换行符转换干扰
        std::ofstream f(DomainToPath(domain), std::ios::binary);
        f.write(content.c_str(), content.size());
        f.close();
    }

    PluginPtr<IConfigManagerService> config_svc_;
    std::filesystem::path test_root_;
};

// =============================================================================
// 3. 核心功能测试
// =============================================================================

/**
 * @test 零配置启动 (Auto Generate Default File)
 * @brief 验证当配置文件不存在时，系统能自动使用代码默认值回填。
 * @details
 * 1. LoadConfig -> 返回 CreatedDefault，内存中被初始化为默认值。
 * 2. 此时磁盘无文件。
 * 3. Save -> 磁盘生成文件。
 */
TEST_F(ConfigPluginTest, AutoGenerateDefaultFile) {
    ServerConfig cfg;
    std::string domain = "server_default";

    // 1. 加载 (文件不存在)
    ConfigStatus status = config_svc_->LoadConfig(domain, "Net", cfg);

    // 验证：状态为 CreatedDefault，且值正确
    EXPECT_EQ(status, ConfigStatus::CreatedDefault);
    EXPECT_EQ(cfg.port, 8080);

    // 验证：此时文件未生成 (Save 才是持久化时机)
    EXPECT_FALSE(FileExists(domain));

    // 2. 保存
    ASSERT_TRUE(config_svc_->Save(domain));

    // 验证：文件已生成
    EXPECT_TRUE(FileExists(domain));
}

/**
 * @test 读写持久化 (Read-Write Cycle)
 * @brief 验证内存修改、落盘保存、重新加载的数据一致性。
 */
TEST_F(ConfigPluginTest, ReadWriteCycle) {
    std::string domain = "rw_cycle";

    // 1. 第一阶段：修改并保存
    {
        ServerConfig cfg;
        cfg.port = 9999;
        config_svc_->SetConfig(domain, "Net", cfg); // 仅修改内存
        config_svc_->Save(domain);                 // 显式落盘
    }

    // 2. 第二阶段：模拟重启 (Reload)
    config_svc_->Reload(domain);

    // 3. 第三阶段：读取验证
    ServerConfig new_cfg; // 初始值为 8080
    ConfigStatus status = config_svc_->LoadConfig(domain, "Net", new_cfg);

    EXPECT_EQ(status, ConfigStatus::Success);
    EXPECT_EQ(new_cfg.port, 9999); // 应为读取到的新值
}

/**
 * @test 探测模式 (Peek Mode)
 * @brief 验证 PeekConfig 不会产生副作用 (不标记脏，不生成文件)。
 */
TEST_F(ConfigPluginTest, PeekModeNoSideEffect) {
    ServerConfig cfg;
    std::string domain = "peek_ghost";

    // 1. Peek 不存在的配置
    ConfigStatus status = config_svc_->PeekConfig(domain, "Net", cfg);
    EXPECT_EQ(status, ConfigStatus::CreatedDefault); // 未命中

    // 2. 即使调用 SaveAll
    config_svc_->SaveAll();

    // 3. 验证：文件依然不存在 (因为 Peek 不标记 dirty)
    EXPECT_FALSE(FileExists(domain));
}

/**
 * @test 侵入式自校验 (Validation Interception)
 * @brief 验证 Validate 函数能成功拦截非法配置。
 */
TEST_F(ConfigPluginTest, ValidationInterception) {
    std::string domain = "validation_test";

    // 1. 制造一个“逻辑非法”的配置文件 (Speed 999 超出 0-100 范围)
    // 注意：JSON 格式是合法的，但业务逻辑不合法
    WriteRawFile(domain, R"({ "Car": { "speed": 999, "name": "Tesla" } })");

    // 2. 尝试加载
    ValidatedConfig cfg;
    ConfigStatus status = config_svc_->LoadConfig(domain, "Car", cfg);

    // 3. 验证拦截
    // 预期：Error (被 Validate 函数拦截)
    EXPECT_EQ(status, ConfigStatus::Error);
    // 预期：cfg 保持初始值 (0)，未被污染
    EXPECT_EQ(cfg.speed, 0);
}

// =============================================================================
// 4. 中文与特殊字符支持 (Unicode)
// =============================================================================

/**
 * @test 中文支持 (Chinese Support)
 * @brief 验证中文文件名、Key 和 Value 在 Windows/Linux 下的正确性。
 * @note 依赖 DomainToPath 的正确实现。
 */
TEST_F(ConfigPluginTest, ChineseSupport) {
    // UTF-8 编码的中文文件名
    std::string domain = "测试_配置_CN";
    ChineseConfig cfg;

    // 1. 写入中文数据
    cfg.message = "你好，世界";
    cfg.location = "上海";
    config_svc_->SetConfig(domain, "基本信息", cfg);
    ASSERT_TRUE(config_svc_->Save(domain));

    // 2. 验证文件已创建
    EXPECT_TRUE(FileExists(domain));

    // 3. 重载并读取验证
    config_svc_->Reload(domain);

    ChineseConfig read_back;
    ConfigStatus status = config_svc_->LoadConfig(domain, "基本信息", read_back);

    EXPECT_EQ(status, ConfigStatus::Success);
    EXPECT_STREQ(read_back.message.c_str(), "你好，世界");
    EXPECT_STREQ(read_back.location.c_str(), "上海");
}

// =============================================================================
// 5. 异常与边界测试 (Exceptions & Edge Cases)
// =============================================================================

/**
 * @test 畸形 JSON 防御 (Corrupted JSON)
 * @brief 验证 JSON 语法错误时，系统能 Fail-Fast 并保留现场。
 */
TEST_F(ConfigPluginTest, CorruptedJsonDefense) {
    std::string domain = "corrupted";
    // 写入一个语法错误的 JSON (少右括号)
    WriteRawFile(domain, R"({ "Net": { "port": 8080 )");

    ServerConfig cfg;
    cfg.port = 1111; // 初始值

    ConfigStatus status = config_svc_->LoadConfig(domain, "Net", cfg);

    // 验证：返回 Error，且结构体未被修改
    EXPECT_EQ(status, ConfigStatus::Error);
    EXPECT_EQ(cfg.port, 1111);
}

/**
 * @test 类型不匹配防御 (Type Mismatch)
 * @brief 验证 JSON 字段类型与结构体不匹配时的处理。
 */
TEST_F(ConfigPluginTest, TypeMismatchDefense) {
    std::string domain = "type_bad";
    // port 应该是 int，这里写成了 string
    WriteRawFile(domain, R"({ "Net": { "port": "not_an_int", "host": "1.1.1.1" } })");

    ServerConfig cfg;
    cfg.port = 2222;

    ConfigStatus status = config_svc_->LoadConfig(domain, "Net", cfg);

    // 验证：加载失败，值未改变
    EXPECT_EQ(status, ConfigStatus::Error);
    EXPECT_EQ(cfg.port, 2222);
}

/**
 * @test 路径遍历防御 (Path Traversal Security)
 * @brief 验证系统能拦截包含 ".." 的恶意路径。
 */
TEST_F(ConfigPluginTest, PathTraversalDefense) {
    ServerConfig cfg;

    // 尝试读取上级目录
    ConfigStatus status = config_svc_->LoadConfig("../../../system_config", "Net", cfg);
    EXPECT_EQ(status, ConfigStatus::Error);

    // 尝试保存到非法路径
    bool save_ok = config_svc_->Save("../../hacker");
    EXPECT_FALSE(save_ok);
}

// =============================================================================
// 6. 运维操作 (Operations)
// =============================================================================

/**
 * @test 恢复出厂设置 (Factory Reset)
 * @brief 验证 ResetConfig 能删除物理文件并重置内存。
 */
TEST_F(ConfigPluginTest, FactoryReset) {
    std::string domain = "reset_target";
    ServerConfig cfg;
    config_svc_->SetConfig(domain, "Key", cfg);
    config_svc_->Save(domain);
    ASSERT_TRUE(FileExists(domain));

    // 执行重置
    config_svc_->ResetConfig(domain);

    // 验证：文件被删除
    EXPECT_FALSE(FileExists(domain));

    // 验证：内存被重置 (再次 Load 会变回默认值)
    ConfigStatus status = config_svc_->LoadConfig(domain, "Key", cfg);
    EXPECT_EQ(status, ConfigStatus::CreatedDefault);
}

/**
 * @test 批量操作 (Batch Operations)
 * @brief 验证 SaveAll 和 ResetAll 能正确处理多个域。
 */
TEST_F(ConfigPluginTest, BatchOperations) {
    ServerConfig cfg;
    config_svc_->SetConfig("d1", "k", cfg);
    config_svc_->SetConfig("d2", "k", cfg);

    // 批量保存
    config_svc_->SaveAll();
    EXPECT_TRUE(FileExists("d1"));
    EXPECT_TRUE(FileExists("d2"));

    // 批量重置
    config_svc_->ResetAll();
    EXPECT_FALSE(FileExists("d1"));
    EXPECT_FALSE(FileExists("d2"));
}